<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Makefile Tutorial | zrf's blog</title><meta name="author" content="zrf,853241825@qq.com"><meta name="copyright" content="zrf"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="翻译一篇Makfile相关文档，给出一个好用的Makefile模板，用以编译小型项目。">
<meta property="og:type" content="article">
<meta property="og:title" content="Makefile Tutorial">
<meta property="og:url" content="https://zzzzrf.github.io/2024/06/08/MakefileTutorial/index.html">
<meta property="og:site_name" content="zrf&#39;s blog">
<meta property="og:description" content="翻译一篇Makfile相关文档，给出一个好用的Makefile模板，用以编译小型项目。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zzzzrf.github.io/blog_image/Makefile/1.png">
<meta property="article:published_time" content="2024-06-08T07:19:25.000Z">
<meta property="article:modified_time" content="2025-02-13T11:53:54.749Z">
<meta property="article:author" content="zrf">
<meta property="article:tag" content="Makefile">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zzzzrf.github.io/blog_image/Makefile/1.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Makefile Tutorial",
  "url": "https://zzzzrf.github.io/2024/06/08/MakefileTutorial/",
  "image": "https://zzzzrf.github.io/blog_image/Makefile/1.png",
  "datePublished": "2024-06-08T07:19:25.000Z",
  "dateModified": "2025-02-13T11:53:54.749Z",
  "author": [
    {
      "@type": "Person",
      "name": "zrf",
      "url": "https://zzzzrf.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zzzzrf.github.io/2024/06/08/MakefileTutorial/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')
          
          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":true,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: zrf","link":"链接: ","source":"来源: zrf's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Makefile Tutorial',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/back.jpeg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/blog_image/Makefile/1.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">zrf's blog</span></a><a class="nav-page-title" href="/"><span class="site-name">Makefile Tutorial</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Makefile Tutorial</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-08T07:19:25.000Z" title="发表于 2024-06-08 15:19:25">2024-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-13T11:53:54.749Z" title="更新于 2025-02-13 19:53:54">2025-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C%E4%BB%A3%E7%A0%81%E8%B0%83%E8%AF%95/">C代码调试</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>27分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;It has been&quot;,&quot;messageNext&quot;:&quot;days since the last update, the content of the article may be outdated.&quot;,&quot;postUpdate&quot;:&quot;2025-02-13 19:53:54&quot;}" hidden></div><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文翻译自<a target="_blank" rel="noopener" href="https://makefiletutorial.com/#makefile-cookbook">https://makefiletutorial.com/#makefile-cookbook</a></p>
<p>我之所以编写这本指南，是因为我始终无法理解 Makefile。它们似乎充斥着隐藏的规则和深奥的符号，问一些简单的问题却得不到简单的答案。为了解决这个问题，我花了几个周末坐下来，阅读了所有关于 Makefile 的资料。我把最关键的知识浓缩到了这本指南中。每个主题都有简要说明和一个自带的示例，你可以自己运行。</p>
<p>如果你基本了解 Make，可以考虑查看 Makefile Cookbook，其中有一个中等规模项目的模板，对 Makefile 的每个部分的作用都有大量注释。</p>
<p>祝你好运，我希望你能战胜 Makefile 这个令人困惑的世界！</p>
<h2 id="一-Getting-Started"><a href="#一-Getting-Started" class="headerlink" title="一. Getting Started"></a>一. Getting Started</h2><h3 id="1-1-为什么需要Makefile"><a href="#1-1-为什么需要Makefile" class="headerlink" title="1.1 为什么需要Makefile"></a>1.1 为什么需要Makefile</h3><p>Makefile 用于帮助决定大型程序的哪些部分需要重新编译。在绝大多数情况下，编译的是 C 或 C++ 文件。其他语言通常也有自己的工具，其作用与 Make 类似。除了编译之外，Make 还可以用于根据文件变化运行一系列指令。本教程将重点介绍 C&#x2F;C++ 编译用例。</p>
<p>下面是一个依赖关系图的示例，您可以用 Make 构建这个依赖关系图。如果任何文件的依赖关系发生变化，该文件将被重新编译：</p>
<p><img src="/blog_image/Makefile/dependency_graph.png" alt="dependency_graph"></p>
<h3 id="1-2-除了Makefile还有什么其他选择"><a href="#1-2-除了Makefile还有什么其他选择" class="headerlink" title="1.2 除了Makefile还有什么其他选择"></a>1.2 除了Makefile还有什么其他选择</h3><p>流行的 C&#x2F;C++ 替代构建系统有 SCons、CMake、Bazel 和 Ninja。一些代码编辑器（如 Microsoft Visual Studio）也有自己的内置构建工具。Java 有 Ant、Maven 和 Gradle。其他语言（如 Go、Rust 和 TypeScript）也有自己的构建工具。</p>
<p>Python、Ruby 和原始 Javascript 等解释型语言不需要类似 Makefile 的工具。Makefile 的目标是根据已更改的文件编译需要编译的文件。但是，当解释型语言中的文件发生变化时，就不需要重新编译了。程序运行时，将使用文件的最新版本。</p>
<h3 id="1-3-运行示例"><a href="#1-3-运行示例" class="headerlink" title="1.3 运行示例"></a>1.3 运行示例</h3><p>要运行这些示例，你需要一个终端并安装 “make”。将每个示例的内容放入一个名为 Makefile 的文件中，然后在该目录下运行 make 命令。让我们从最简单的 Makefile 开始：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">    echo <span class="string">&quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里是运行后的输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zrf@debian:/tmp$ make</span><br><span class="line">echo &quot;Hello, World&quot;</span><br><span class="line">Hello, World</span><br></pre></td></tr></table></figure>

<p>就是这样！如果你还有些困惑，这里有一段视频，详细介绍了这些步骤，以及 Makefile 的基本结构。</p>
<p><a target="_blank" rel="noopener" href="https://youtu.be/zeEMISsjO38">https://youtu.be/zeEMISsjO38</a></p>
<h3 id="1-4-Makefile语法"><a href="#1-4-Makefile语法" class="headerlink" title="1.4 Makefile语法"></a>1.4 Makefile语法</h3><p>Makefile 由一系列规则组成。规则一般是这样的</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets: prerequisites</span></span><br><span class="line">    command</span><br><span class="line">    command</span><br><span class="line">    command</span><br></pre></td></tr></table></figure>

<ul>
<li>targets是文件名，以空格分隔。通常情况下，每条规则只有一个目标。</li>
<li>command是用于创建targets的一系列步骤。这些命令需要以制表符开头，而不是空格。</li>
<li>prerequisites(先觉条件)也是文件名，以空格分隔。在运行目标的命令之前，这些文件必须存在。这些文件也称为依赖项</li>
</ul>
<h3 id="1-5-Make的本质"><a href="#1-5-Make的本质" class="headerlink" title="1.5 Make的本质"></a>1.5 Make的本质</h3><p>让我们以hello world作为示例：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hello:</span></span><br><span class="line">    echo <span class="string">&quot;Hello, World&quot;</span></span><br><span class="line">    echo <span class="string">&quot;This line will print if the file hello does not exist.&quot;</span></span><br></pre></td></tr></table></figure>

<p>这里已经有很多东西需要了解。让我们来分解一下：</p>
<ul>
<li>我们有一个名为 hello 的目标</li>
<li>这个目标有两个命令</li>
<li>该目标没有先决条件</li>
</ul>
<p>然后运行 make hello。只要 hello 文件不存在，命令就会运行。如果 hello 文件存在，则不会运行任何命令。</p>
<p>要知道，我所说的 hello 既是目标，也是文件。这是因为两者直接联系在一起。通常情况下，当运行目标文件时（也就是运行目标文件的命令时），命令会创建一个与目标文件同名的文件。在当前的例子中，hello 目标并不会创建 hello 文件。</p>
<p>让我们创建一个更典型的 Makefile–一个编译单个 C 文件的 Makefile。在此之前，先创建一个名为 blah.c 的文件，其内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blah.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个Makefile</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">blah:</span></span><br><span class="line">    cc blah.c -o blah</span><br></pre></td></tr></table></figure>

<p>这次，请尝试直接运行 make。由于 make 命令的参数中没有提供目标文件，因此会运行第一个目标文件。在本例中，只有一个目标（blah）。第一次运行时，blah 将被创建。第二次运行时，你会看到 make: ‘blah’ 是最新的。这是因为 blah 文件已经存在。但有一个问题：如果我们修改了 blah.c，然后运行 make，什么也不会重新编译。</p>
<p>为了解决修改源文件，目标文件不会重新编译的问题，我们为Makefile添加先觉条件：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">blah: blah.c</span></span><br><span class="line">    cc blah.c -o blah</span><br></pre></td></tr></table></figure>

<p>当我们再次运行make时，会执行这些步骤</p>
<ul>
<li>选择了第一个目标，因为第一个目标是默认目标</li>
<li>它的前提条件是 blah.c</li>
<li>Make 决定是否运行 blah 目标。只有当 blah 不存在，或 blah.c 比 blah 新时，它才会运行</li>
</ul>
<p>最后一步至关重要，是 make 的精髓所在。它要做的是判断自上次编译 blah 以来，blah 的先决条件是否发生了变化。也就是说，如果 blah.c 被修改了，运行 make 就应该重新编译该文件。反之，如果 blah.c 没有改变，则不应重新编译。</p>
<p>为了做到这一点，它会使用文件系统时间戳作为代理来判断是否有内容发生了更改。这是一种合理的启发式方法，因为文件时间戳通常只有在文件被修改时才会发生变化。但必须认识到，情况并非总是如此。例如，你可以修改一个文件，然后把该文件的修改时间戳改成旧的。如果你这样做了，Make 就会错误地认为该文件没有更改，从而忽略它。</p>
<p>请务必理解这一点。这是 Makefile 的关键所在，可能需要花几分钟时间才能正确理解。如果还是不明白，请参考上面的示例或观看上面的视频。</p>
<h3 id="1-6-更多快速示例"><a href="#1-6-更多快速示例" class="headerlink" title="1.6 更多快速示例"></a>1.6 更多快速示例</h3><p>下面的 Makefile 最终会运行所有三个目标。当你在终端运行 make 时，它会通过一系列步骤构建一个名为 blah 的程序：</p>
<ul>
<li>make 选择目标 blah，因为第一个目标是默认目标</li>
<li>blah 需要 blah.o，所以 make 搜索 blah.o 目标</li>
<li>blah.o 需要 blah.c，所以 make 会搜索 blah.c 目标</li>
<li>blah.c 没有依赖关系，因此运行 echo 命令</li>
<li>然后运行 cc -c 命令，因为所有 blah.o 的依赖关系都已完成</li>
<li>运行 top cc 命令，因为所有 blah 的依赖关系都已完成</li>
<li>就是这样：blah 是一个编译过的 c 程序</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">blah: blah.o</span></span><br><span class="line">    cc blah.o -o blah <span class="comment"># Runs third</span></span><br><span class="line"></span><br><span class="line"><span class="section">blah.o: blah.c</span></span><br><span class="line">    cc -c blah.c -o blah.o <span class="comment"># Runs second</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Typically blah.c would already exist, but I want to limit any additional required files</span></span><br><span class="line"><span class="section">blah.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; blah.c <span class="comment"># Runs first</span></span><br></pre></td></tr></table></figure>

<p>如果删除 blah.c，所有三个目标都将重新运行。如果编辑它（从而将时间戳改为比 blah.o 新），则会运行前两个目标。如果运行 touch blah.o（从而将时间戳改为比 blah 更新），则只会运行第一个目标。如果什么都不改，则所有目标都不会运行。试试看</p>
<p>下一个示例没有做任何新内容，但仍然是一个很好的补充示例。它将始终运行两个目标，因为 some_file 依赖于 other_file，而 other_file 从未创建。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">some_file: other_file</span><br><span class="line">    echo &quot;This will always run, and runs second&quot;</span><br><span class="line">    touch some_file</span><br><span class="line"></span><br><span class="line">other_file:</span><br><span class="line">    echo &quot;This will always run, and runs first&quot;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-Make-clean"><a href="#1-7-Make-clean" class="headerlink" title="1.7 Make clean"></a>1.7 Make clean</h3><p>clean 经常被用作删除其他目标的输出的目标，但它在 Make 中并不是一个特殊的词。你可以运行 make 和 make clean 来创建和删除 some_file。</p>
<p>请注意，clean在这里做了两件新事情：</p>
<p>它不是第一目标（默认），也不是先决条件。这意味着除非明确调用 make clean，否则它永远不会运行。<br>它不是一个文件名。如果你碰巧有一个名为 clean 的文件，这个目标就不会运行，这不是我们想要的。如何解决这个问题，请参见本教程后面的 .PHONY 部分</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">some_file: </span></span><br><span class="line">    touch some_file</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f some_file</span><br></pre></td></tr></table></figure>

<h3 id="1-8-变量"><a href="#1-8-变量" class="headerlink" title="1.8 变量"></a>1.8 变量</h3><p>变量只能是字符串。通常要使用 :&#x3D;，但 &#x3D; 也可以。参见变量 Pt 2。</p>
<p>下面是一个使用变量的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">files := file1 file2</span><br><span class="line">some_file: $(files)</span><br><span class="line">    echo &quot;Look at this variable: &quot; $(files)</span><br><span class="line">    touch some_file</span><br><span class="line"></span><br><span class="line">file1:</span><br><span class="line">    touch file1</span><br><span class="line">file2:</span><br><span class="line">    touch file2</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f file1 file2 some_file</span><br></pre></td></tr></table></figure>

<p>单引号或双引号对 Make 没有任何意义。它们只是分配给变量的字符。不过，引号对 shell&#x2F;bash 很有用，在 printf 等命令中需要用到它们。在本例中，两个命令的行为是一样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a := one two # a is set to the string &quot;one two&quot;</span><br><span class="line">b := &#x27;one two&#x27; # Not recommended. b is set to the string &quot;&#x27;one two&#x27;&quot;</span><br><span class="line">all:</span><br><span class="line">    printf &#x27;$a&#x27;</span><br><span class="line">    printf $b</span><br></pre></td></tr></table></figure>

<p>使用 ${} 或 $() 引用变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x := dude</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(x)</span></span><br><span class="line">    echo $&#123;x&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Bad practice, but works</span></span><br><span class="line">    echo $x </span><br></pre></td></tr></table></figure>

<h2 id="二-Target"><a href="#二-Target" class="headerlink" title="二. Target"></a>二. Target</h2><h3 id="2-1-all-target"><a href="#2-1-all-target" class="headerlink" title="2.1 all target"></a>2.1 all target</h3><p>制作多个目标，并希望所有目标都运行？制作一个全部目标。由于这是列出的第一条规则，因此如果调用 make 而未指定目标，它将默认运行。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: one two three</span></span><br><span class="line"></span><br><span class="line"><span class="section">one:</span></span><br><span class="line">    touch one</span><br><span class="line"><span class="section">two:</span></span><br><span class="line">    touch two</span><br><span class="line"><span class="section">three:</span></span><br><span class="line">    touch three</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f one two three</span><br></pre></td></tr></table></figure>

<h3 id="2-2-多目标"><a href="#2-2-多目标" class="headerlink" title="2.2 多目标"></a>2.2 多目标</h3><p>当一条规则有多个目标时，将针对每个目标运行命令。$@ 是一个自动变量，包含目标名称。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">all: f1.o f2.o</span><br><span class="line"></span><br><span class="line">f1.o f2.o:</span><br><span class="line">    echo $@</span><br><span class="line"># Equivalent to:</span><br><span class="line"># f1.o:</span><br><span class="line">#   echo f1.o</span><br><span class="line"># f2.o:</span><br><span class="line">#   echo f2.o</span><br></pre></td></tr></table></figure>

<h2 id="三-自动变量和通配符"><a href="#三-自动变量和通配符" class="headerlink" title="三. 自动变量和通配符"></a>三. 自动变量和通配符</h2><h3 id="3-1-wildcard"><a href="#3-1-wildcard" class="headerlink" title="3.1 * wildcard"></a>3.1 * wildcard</h3><p>在 Make 中，* 和 % 都被称为通配符，但它们的含义完全不同。* 在文件系统中搜索匹配的文件名。我建议你始终将其封装在wildcard函数中，否则你可能会陷入下面描述的一个常见陷阱。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Print out file information about every .c file</span></span><br><span class="line"><span class="section">print: $(wildcard *.c)</span></span><br><span class="line">    ls -la  <span class="variable">$?</span></span><br></pre></td></tr></table></figure>

<p>* 可以在目标、先决条件或通配符功能中使用。</p>
<p>危险: * 不能在变量定义中直接使用。</p>
<p>危险：当 * 不能匹配任何文件时，它将保持原样（除非在通配符函数中运行）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">thing_wrong := *.o <span class="comment"># Don&#x27;t do this! &#x27;*&#x27; will not get expanded</span></span><br><span class="line">thing_right := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: one two three four</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fails, because $(thing_wrong) is the string &quot;*.o&quot;</span></span><br><span class="line"><span class="section">one: <span class="variable">$(thing_wrong)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stays as *.o if there are no files that match this pattern :(</span></span><br><span class="line"><span class="section">two: *.o </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Works as you would expect! In this case, it does nothing.</span></span><br><span class="line"><span class="section">three: <span class="variable">$(thing_right)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Same as rule three</span></span><br><span class="line"><span class="section">four: $(wildcard *.o)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-Wildcard"><a href="#3-2-Wildcard" class="headerlink" title="3.2 % Wildcard"></a>3.2 % Wildcard</h3><p>% 确实很有用，但由于可用于多种情况，所以有点令人困惑。</p>
<ul>
<li>在 “匹配” 模式下使用时，它会匹配字符串中的一个或多个字符。这种匹配称为词干。</li>
<li>在 “替换” 模式下使用时，它会将匹配到的词干替换到字符串中。</li>
<li>% 通常用于规则定义和某些特定功能中。</li>
</ul>
<h3 id="3-3-自动变量"><a href="#3-3-自动变量" class="headerlink" title="3.3 自动变量"></a>3.3 自动变量</h3><p><a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">自动变量</a>有很多，但往往只有少数几个会出现：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">hey: one two</span></span><br><span class="line">    <span class="comment"># Outputs &quot;hey&quot;, since this is the target name</span></span><br><span class="line">    echo <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Outputs all prerequisites newer than the target</span></span><br><span class="line">    echo <span class="variable">$?</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Outputs all prerequisites</span></span><br><span class="line">    echo <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line">    touch hey</span><br><span class="line"></span><br><span class="line"><span class="section">one:</span></span><br><span class="line">    touch one</span><br><span class="line"></span><br><span class="line"><span class="section">two:</span></span><br><span class="line">    touch two</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f hey one two</span><br></pre></td></tr></table></figure>

<h2 id="四-规则"><a href="#四-规则" class="headerlink" title="四. 规则"></a>四. 规则</h2><h3 id="4-1-隐式规则"><a href="#4-1-隐式规则" class="headerlink" title="4.1 隐式规则"></a>4.1 隐式规则</h3><p>Make 中最令人困惑的部分可能是那些神奇的自动规则。Make 将这些规则称为 “隐含 “规则。我个人并不同意这一设计决定，也不建议使用它们，但它们经常被使用，因此了解它们很有用。下面是隐含规则的列表：</p>
<ul>
<li>编译 C 程序：使用 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ 形式的命令从 n.c 自动生成 n.o。</li>
<li>编译 C++ 程序：使用形式为 $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ 的命令，可自动从 n.cc 或 n.cpp 生成 n.o</li>
<li>链接单个对象文件：通过运行 $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 命令，可从 n.o 自动生成 n</li>
</ul>
<p>隐式规则使用的重要变量有：</p>
<ul>
<li>CC： 编译 C 程序的程序；默认为 cc</li>
<li>CXX： 用于编译 C++ 程序的程序；默认为 g++</li>
<li>CFLAGS：提供给 C 编译器的额外标志</li>
<li>CXXFLAGS：提供给 C++ 编译器的额外标志</li>
<li>CPPFLAGS：提供给 C 预处理器的额外标记</li>
<li>LDFLAGS：在编译器调用链接器时提供给编译器的额外标记</li>
</ul>
<p>让我们看看如何在不明确告诉 Make 如何编译的情况下编译 C 程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc # Flag for implicit rules</span><br><span class="line">CFLAGS = -g # Flag for implicit rules. Turn on debug info</span><br><span class="line"></span><br><span class="line"># Implicit rule #1: blah is built via the C linker implicit rule</span><br><span class="line"># Implicit rule #2: blah.o is built via the C compilation implicit rule, because blah.c exists</span><br><span class="line">blah: blah.o</span><br><span class="line"></span><br><span class="line">blah.c:</span><br><span class="line">    echo &quot;int main() &#123; return 0; &#125;&quot; &gt; blah.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f blah*</span><br></pre></td></tr></table></figure>

<h3 id="4-2-静态模式规则"><a href="#4-2-静态模式规则" class="headerlink" title="4.2 静态模式规则"></a>4.2 静态模式规则</h3><p>静态模式规则是在 Makefile 中减少编写内容的另一种方法，但我认为它更有用，而且不那么 “神奇”。下面是它们的语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">targets...: target-pattern: prereq-patterns ...</span></span><br><span class="line">   commands</span><br></pre></td></tr></table></figure>

<p>其实质是通过目标模式（通过 % 通配符）匹配给定目标。匹配到的内容称为词干。然后将词干代入先决条件模式，生成目标的先决条件。</p>
<p>一个典型的用例是将 .c 文件编译成 .o 文件。下面是手动方法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o all.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These files compile via implicit rules</span></span><br><span class="line"><span class="section">foo.o: foo.c</span></span><br><span class="line"><span class="section">bar.o: bar.c</span></span><br><span class="line"><span class="section">all.o: all.c</span></span><br><span class="line"></span><br><span class="line"><span class="section">all.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c</span><br><span class="line"></span><br><span class="line"><span class="section">%.c:</span></span><br><span class="line">    touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.c *.o all</span><br></pre></td></tr></table></figure>

<p>下面是使用静态模式规则的更有效方法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o all.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># These files compile via implicit rules</span></span><br><span class="line"><span class="comment"># Syntax - targets ...: target-pattern: prereq-patterns ...</span></span><br><span class="line"><span class="comment"># In the case of the first target, foo.o, the target-pattern matches foo.o and sets the &quot;stem&quot; to be &quot;foo&quot;.</span></span><br><span class="line"><span class="comment"># It then replaces the &#x27;%&#x27; in prereq-patterns with that stem</span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line"></span><br><span class="line"><span class="section">all.c:</span></span><br><span class="line">    echo <span class="string">&quot;int main() &#123; return 0; &#125;&quot;</span> &gt; all.c</span><br><span class="line"></span><br><span class="line"><span class="section">%.c:</span></span><br><span class="line">    touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.c *.o all</span><br></pre></td></tr></table></figure>

<h3 id="4-3-静态模式规则和过滤器"><a href="#4-3-静态模式规则和过滤器" class="headerlink" title="4.3 静态模式规则和过滤器"></a>4.3 静态模式规则和过滤器</h3><p>在稍后介绍函数的同时，我将先介绍一下可以用它们做些什么。过滤器函数可用于静态模式规则，以匹配正确的文件。在本例中，我制作了 .raw 和 .result 扩展名。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">obj_files = foo.result bar.o lose.o</span><br><span class="line">src_files = foo.raw bar.c lose.c</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(obj_files)</span></span></span><br><span class="line"><span class="comment"># Note: PHONY is important here. Without it, implicit rules will try to build the executable &quot;all&quot;, since the prereqs are &quot;.o&quot; files.</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: all </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ex 1: .o files depend on .c files. Though we don&#x27;t actually make the .o file.</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.o,<span class="variable">$(obj_files)</span>)</span>: %.o: %.c</span><br><span class="line">    echo <span class="string">&quot;target: <span class="variable">$@</span> prereq: <span class="variable">$&lt;</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Ex 2: .result files depend on .raw files. Though we don&#x27;t actually make the .result file.</span></span><br><span class="line"><span class="variable">$(<span class="built_in">filter</span> %.result,<span class="variable">$(obj_files)</span>)</span>: %.result: %.raw</span><br><span class="line">    echo <span class="string">&quot;target: <span class="variable">$@</span> prereq: <span class="variable">$&lt;</span>&quot;</span> </span><br><span class="line"></span><br><span class="line">%.c %.raw:</span><br><span class="line">    touch <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(src_files)</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-Pattern-Rules"><a href="#4-4-Pattern-Rules" class="headerlink" title="4.4 Pattern Rules"></a>4.4 Pattern Rules</h3><p>Pattern Rules经常被使用，但却很容易混淆。您可以从两个方面来看待它们：</p>
<ul>
<li>定义自己的隐式规则</li>
<li>一种更简单的静态模式规则</li>
</ul>
<p>我们先来看一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define a pattern rule that compiles every .c file into a .o file</span></span><br><span class="line">%.o : %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>模式规则在目标中包含一个”%”。该’%’匹配任何非空字符串，其他字符则自行匹配。模式规则先决条件中的”%”代表与目标中的”%”匹配的同一词干。</p>
<h3 id="4-5-双冒号规则"><a href="#4-5-双冒号规则" class="headerlink" title="4.5 双冒号规则"></a>4.5 双冒号规则</h3><p>双冒号规则很少使用，但允许为同一目标定义多个规则。如果是单冒号，则会打印警告，并且只会运行第二组命令。</p>
<h2 id="五-Commands-and-execution"><a href="#五-Commands-and-execution" class="headerlink" title="五. Commands and execution"></a>五. Commands and execution</h2><h3 id="5-1-命令行的输出-静默"><a href="#5-1-命令行的输出-静默" class="headerlink" title="5.1 命令行的输出&#x2F;静默"></a>5.1 命令行的输出&#x2F;静默</h3><p>在命令前添加 @ 以阻止命令被打印出来<br>您也可以使用 -s 运行 make，在每一行前添加 @</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="string">&quot;This make line will not be printed&quot;</span></span><br><span class="line">    echo <span class="string">&quot;But this will&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-命令行的执行"><a href="#5-2-命令行的执行" class="headerlink" title="5.2 命令行的执行"></a>5.2 命令行的执行</h3><p>每条命令都在一个新的 shell 中运行（至少效果是这样的）</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">    cd ..</span><br><span class="line">    <span class="comment"># The cd above does not affect this line, because each command is effectively run in a new shell</span></span><br><span class="line">    echo `pwd`</span><br><span class="line"></span><br><span class="line">    <span class="comment"># This cd command affects the next because they are on the same line</span></span><br><span class="line">    cd ..;echo `pwd`</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Same as above</span></span><br><span class="line">    cd ..; \</span><br><span class="line">    echo `pwd`</span><br></pre></td></tr></table></figure>

<h3 id="5-3-默认shell"><a href="#5-3-默认shell" class="headerlink" title="5.3 默认shell"></a>5.3 默认shell</h3><p>默认 shell 为 &#x2F;bin&#x2F;sh。你可以通过修改变量 SHELL 来改变它：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SHELL=/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="section">cool:</span></span><br><span class="line">    echo <span class="string">&quot;Hello from bash&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-4-双美元符号"><a href="#5-4-双美元符号" class="headerlink" title="5.4 双美元符号"></a>5.4 双美元符号</h3><p>如果希望字符串带有美元符号，可以使用 $$。这就是如何在 bash 或 sh 中使用 shell 变量。</p>
<p>请注意 Makefile 变量和 Shell 变量之间的区别。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">make_var = I am a make variable</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="comment"># Same as running &quot;sh_var=&#x27;I am a shell variable&#x27;; echo $sh_var&quot; in the shell</span></span><br><span class="line">    sh_var=&#x27;I am a shell variable&#x27;; echo $$sh_var</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Same as running &quot;echo I am a make variable&quot; in the shell</span></span><br><span class="line">    echo <span class="variable">$(make_var)</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-使用-k、-i-和-处理错误"><a href="#5-5-使用-k、-i-和-处理错误" class="headerlink" title="5.5 使用 -k、-i 和 - 处理错误"></a>5.5 使用 -k、-i 和 - 处理错误</h3><p>运行 make 时添加 -k，即使出现错误也能继续运行。如果你想一次性看到 Make 的所有错误，这很有用。<br>在命令前添加 - 来抑制错误<br>在 make 中添加 -i 可让每条命令都出错。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">one:</span></span><br><span class="line">    <span class="comment"># This error will be printed but ignored, and make will continue to run</span></span><br><span class="line">    -false</span><br><span class="line">    touch one</span><br></pre></td></tr></table></figure>

<h3 id="5-6-中断或杀死"><a href="#5-6-中断或杀死" class="headerlink" title="5.6 中断或杀死"></a>5.6 中断或杀死</h3><p>请注意：如果按 ctrl+c ，它将删除刚刚make的新目标。</p>
<h3 id="5-7-make-的递归使用"><a href="#5-7-make-的递归使用" class="headerlink" title="5.7 make 的递归使用"></a>5.7 make 的递归使用</h3><p>要递归调用 makefile，请使用特殊的 $(MAKE) 而不是 make，因为它会为你传递 make 标志，而自身不会受其影响。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_contents = <span class="string">&quot;hello:\n\ttouch inside_file&quot;</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    mkdir -p subdir</span><br><span class="line">    printf <span class="variable">$(new_contents)</span> | sed -e &#x27;s/^ //&#x27; &gt; subdir/makefile</span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf subdir</span><br></pre></td></tr></table></figure>

<h3 id="5-8-导出、环境和递归-make"><a href="#5-8-导出、环境和递归-make" class="headerlink" title="5.8 导出、环境和递归 make"></a>5.8 导出、环境和递归 make</h3><p>当 Make 启动时，它会自动从执行时设置的所有环境变量中创建 Make 变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Run this with &quot;export shell_env_var=&#x27;I am an environment variable&#x27;; make&quot;</span></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="comment"># Print out the Shell variable</span></span><br><span class="line">    echo $$shell_env_var</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Print out the Make variable</span></span><br><span class="line">    echo <span class="variable">$(shell_env_var)</span></span><br></pre></td></tr></table></figure>

<p>The export directive takes a variable and sets it the environment for all shell commands in all the recipes:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">shell_env_var=Shell env var, created inside of Make</span><br><span class="line"><span class="keyword">export</span> shell_env_var</span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(shell_env_var)</span></span><br><span class="line">    echo $$shell_env_var</span><br></pre></td></tr></table></figure>

<p>因此，在 make 中运行 make 命令时，可以使用 export 指令使子 make 命令可以访问它。在本例中，cooly 被导出，以便子目录中的 makefile 可以使用它。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">new_contents = <span class="string">&quot;hello:\n\techo \$<span class="variable">$(cooly)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    mkdir -p subdir</span><br><span class="line">    printf <span class="variable">$(new_contents)</span> | sed -e &#x27;s/^ //&#x27; &gt; subdir/makefile</span><br><span class="line">    @echo <span class="string">&quot;---MAKEFILE CONTENTS---&quot;</span></span><br><span class="line">    @cd subdir &amp;&amp; cat makefile</span><br><span class="line">    @echo <span class="string">&quot;---END MAKEFILE CONTENTS---&quot;</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that variables and exports. They are set/affected globally.</span></span><br><span class="line">cooly = <span class="string">&quot;The subdirectory can see me!&quot;</span></span><br><span class="line"><span class="keyword">export</span> cooly</span><br><span class="line"><span class="comment"># This would nullify the line above: unexport cooly</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf subdir</span><br></pre></td></tr></table></figure>

<p>您还需要导出变量，以便在 shell 中运行。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">one=this will only work locally</span><br><span class="line"><span class="keyword">export</span> two=we can run subcommands with this</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="variable">$(one)</span></span><br><span class="line">    @echo $$one</span><br><span class="line">    @echo <span class="variable">$(two)</span></span><br><span class="line">    @echo $$two</span><br></pre></td></tr></table></figure>

<p>.EXPORT_ALL_VARIABLES 会为您导出所有变量。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.EXPORT_ALL_VARIABLES:</span></span><br><span class="line">new_contents = <span class="string">&quot;hello:\n\techo \$<span class="variable">$(cooly)</span>&quot;</span></span><br><span class="line"></span><br><span class="line">cooly = <span class="string">&quot;The subdirectory can see me!&quot;</span></span><br><span class="line"><span class="comment"># This would nullify the line above: unexport cooly</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    mkdir -p subdir</span><br><span class="line">    printf <span class="variable">$(new_contents)</span> | sed -e &#x27;s/^ //&#x27; &gt; subdir/makefile</span><br><span class="line">    @echo <span class="string">&quot;---MAKEFILE CONTENTS---&quot;</span></span><br><span class="line">    @cd subdir &amp;&amp; cat makefile</span><br><span class="line">    @echo <span class="string">&quot;---END MAKEFILE CONTENTS---&quot;</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -rf subdir</span><br></pre></td></tr></table></figure>

<h3 id="5-9-make的参数"><a href="#5-9-make的参数" class="headerlink" title="5.9 make的参数"></a>5.9 make的参数</h3><p>有很多的<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/make.html#Options-Summary">选项列表</a>，可以通过 make 运行。请查看–fry-run、–touch、–old&#x3D;file。</p>
<p>你可以为 make 设置多个目标，例如，make clean run test 运行 clean 目标，然后运行，最后测试。</p>
<h2 id="六-变量-2"><a href="#六-变量-2" class="headerlink" title="六. 变量 2"></a>六. 变量 2</h2><h3 id="6-1-Flavors-and-modification"><a href="#6-1-Flavors-and-modification" class="headerlink" title="6.1 Flavors and modification"></a>6.1 Flavors and modification</h3><p>变量有两种：</p>
<ul>
<li>递归（使用 &#x3D;）–只在使用命令时查找变量，而不是在定义变量时。</li>
<li>简单扩展（使用 :&#x3D;）–就像普通的命令式编程一样–只有到目前为止定义的变量才会被扩展</li>
</ul>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Recursive variable. This will print &quot;later&quot; below</span></span><br><span class="line">one = one $&#123;later_variable&#125;</span><br><span class="line"><span class="comment"># Simply expanded variable. This will not print &quot;later&quot; below</span></span><br><span class="line">two := two $&#123;later_variable&#125;</span><br><span class="line"></span><br><span class="line">later_variable = later</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="variable">$(one)</span></span><br><span class="line">    echo <span class="variable">$(two)</span></span><br></pre></td></tr></table></figure>

<p>简单扩展（使用 :&#x3D;）就可以追加到变量中。递归定义将导致无限循环错误。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">one = hello</span><br><span class="line"><span class="comment"># one gets defined as a simply expanded variable (:=) and thus can handle appending</span></span><br><span class="line">one := $&#123;one&#125; there</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="variable">$(one)</span></span><br></pre></td></tr></table></figure>

<p>?&#x3D; 仅设置尚未设置的变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">one = hello</span><br><span class="line">one ?= will not be set</span><br><span class="line">two ?= will be set</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="variable">$(one)</span></span><br><span class="line">    echo <span class="variable">$(two)</span></span><br></pre></td></tr></table></figure>

<p>行尾的空格不会被删除，但行首的空格会被删除。要使用单空格创建变量，请使用 $(nullstring)</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">with_spaces = hello   <span class="comment"># with_spaces has many spaces after &quot;hello&quot;</span></span><br><span class="line">after = <span class="variable">$(with_spaces)</span>there</span><br><span class="line"></span><br><span class="line">nullstring =</span><br><span class="line">space = <span class="variable">$(nullstring)</span> <span class="comment"># Make a variable with a single space.</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="string">&quot;<span class="variable">$(after)</span>&quot;</span></span><br><span class="line">    echo start<span class="string">&quot;<span class="variable">$(space)</span>&quot;</span>end</span><br></pre></td></tr></table></figure>

<p>未定义变量实际上是一个空字符串！</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">    <span class="comment"># Undefined variables are just empty strings!</span></span><br><span class="line">    echo <span class="variable">$(nowhere)</span></span><br></pre></td></tr></table></figure>

<p>使用 +&#x3D; 来扩展</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">foo := start</span><br><span class="line">foo += more</span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="variable">$(foo)</span></span><br></pre></td></tr></table></figure>

<p>字符串替换也是修改变量的一种非常常见和有用的方法。还可以查看文本函数和文件名函数。</p>
<h3 id="6-2-命令行参数和覆盖"><a href="#6-2-命令行参数和覆盖" class="headerlink" title="6.2 命令行参数和覆盖"></a>6.2 命令行参数和覆盖</h3><p>使用 override 可以覆盖命令行变量。在这里，我们使用 make option_one&#x3D;hi 运行 make</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Overrides command line arguments</span></span><br><span class="line"><span class="keyword">override</span> option_one = did_override</span><br><span class="line"><span class="comment"># Does not override command line arguments</span></span><br><span class="line">option_two = not_override</span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    echo <span class="variable">$(option_one)</span></span><br><span class="line">    echo <span class="variable">$(option_two)</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-List-of-commands-and-define"><a href="#6-3-List-of-commands-and-define" class="headerlink" title="6.3 List of commands and define"></a>6.3 List of commands and define</h3><p>define并不是一个函数，尽管它看起来像。我见过它的使用频率很低，所以就不细说了，但它主要用于定义canned recipes ，还能与 eval 函数很好地搭配使用。</p>
<p>define&#x2F;endef 简单地创建一个变量，并将其设置为一系列命令。请注意，这与在命令之间使用分号有点不同，因为每个命令都会在单独的 shell 中运行。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">one = <span class="keyword">export</span> blah=<span class="string">&quot;I was set!&quot;</span>; echo $$blah</span><br><span class="line"></span><br><span class="line"><span class="keyword">define</span> two</span><br><span class="line"><span class="keyword">export</span> blah=<span class="string">&quot;I was set!&quot;</span></span><br><span class="line">echo $$blah</span><br><span class="line"><span class="keyword">endef</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="string">&quot;This prints &#x27;I was set&#x27;&quot;</span></span><br><span class="line">    @<span class="variable">$(one)</span></span><br><span class="line">    @echo <span class="string">&quot;This does not print &#x27;I was set&#x27; because each command runs in a separate shell&quot;</span></span><br><span class="line">    @<span class="variable">$(two)</span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-Target-specific-variables"><a href="#6-4-Target-specific-variables" class="headerlink" title="6.4 Target-specific variables"></a>6.4 Target-specific variables</h3><p>可为特定目标设置变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all: one = cool</span><br><span class="line"></span><br><span class="line">all: </span><br><span class="line">    echo one is defined: $(one)</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line">    echo one is nothing: $(one)</span><br></pre></td></tr></table></figure>

<h3 id="6-5-Pattern-specific-variables"><a href="#6-5-Pattern-specific-variables" class="headerlink" title="6.5 Pattern-specific variables"></a>6.5 Pattern-specific variables</h3><p>您可以为特定目标模式设置变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">%.c: one = cool</span><br><span class="line"></span><br><span class="line">blah.c: </span><br><span class="line">    echo one is defined: $(one)</span><br><span class="line"></span><br><span class="line">other:</span><br><span class="line">    echo one is nothing: $(one)</span><br></pre></td></tr></table></figure>

<h2 id="七-条件判断"><a href="#七-条件判断" class="headerlink" title="七. 条件判断"></a>七. 条件判断</h2><h3 id="7-1-if-else"><a href="#7-1-if-else" class="headerlink" title="7.1 if&#x2F;else"></a>7.1 if&#x2F;else</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo = ok</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(foo)</span>, ok)</span><br><span class="line">    echo <span class="string">&quot;foo equals ok&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    echo <span class="string">&quot;nope&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-检查变量是否为空"><a href="#7-2-检查变量是否为空" class="headerlink" title="7.2 检查变量是否为空"></a>7.2 检查变量是否为空</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">nullstring =</span><br><span class="line">foo = <span class="variable">$(nullstring)</span> <span class="comment"># end of line; there is a space here</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(<span class="built_in">strip</span> <span class="variable">$(foo)</span>)</span>,)</span><br><span class="line">    echo <span class="string">&quot;foo is empty after being stripped&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifeq</span> (<span class="variable">$(nullstring)</span>,)</span><br><span class="line">    echo <span class="string">&quot;nullstring doesn&#x27;t even have spaces&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-检查变量是否已定义"><a href="#7-3-检查变量是否已定义" class="headerlink" title="7.3 检查变量是否已定义"></a>7.3 检查变量是否已定义</h3><p>ifdef 不会扩展变量引用；它只是查看是否定义了某个变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bar =</span><br><span class="line">foo = <span class="variable">$(bar)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="keyword">ifdef</span> foo</span><br><span class="line">    echo <span class="string">&quot;foo is defined&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="keyword">ifndef</span> bar</span><br><span class="line">    echo <span class="string">&quot;but bar is not&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h3 id="7-4-MAKEFLAGS"><a href="#7-4-MAKEFLAGS" class="headerlink" title="7.4 $(MAKEFLAGS)"></a>7.4 $(MAKEFLAGS)</h3><p>本例演示如何使用 findstring 和 MAKEFLAGS 测试 make 标志。使用 make -i 运行此示例，即可看到它打印出 echo 语句。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br><span class="line"><span class="comment"># Search for the &quot;-i&quot; flag. MAKEFLAGS is just a list of single characters, one per flag. So look for &quot;i&quot; in this case.</span></span><br><span class="line"><span class="keyword">ifneq</span> (,<span class="variable">$(<span class="built_in">findstring</span> i, <span class="variable">$(MAKEFLAGS)</span>)</span>)</span><br><span class="line">    echo <span class="string">&quot;i was passed to MAKEFLAGS&quot;</span></span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure>

<h2 id="八-函数"><a href="#八-函数" class="headerlink" title="八. 函数"></a>八. 函数</h2><h3 id="8-1-First-function"><a href="#8-1-First-function" class="headerlink" title="8.1 First function"></a>8.1 First function</h3><p>函数主要用于文本处理。使用 $(fn, arguments) 或 ${fn, arguments} 调用函数。Make 有大量内置函数。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bar := $&#123;subst not,totally, <span class="string">&quot;I am not superman&quot;</span>&#125;</span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<p>如果要替换空格或逗号，请使用变量</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">comma := ,</span><br><span class="line">empty:=</span><br><span class="line">space := <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo := a b c</span><br><span class="line">bar := <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>,<span class="variable">$(comma)</span>,<span class="variable">$(foo)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<p>在第一个参数之后的参数中不要包含空格。空格将被视为字符串的一部分。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">comma := ,</span><br><span class="line">empty:=</span><br><span class="line">space := <span class="variable">$(empty)</span> <span class="variable">$(empty)</span></span><br><span class="line">foo := a b c</span><br><span class="line">bar := <span class="variable">$(<span class="built_in">subst</span> <span class="variable">$(space)</span>, <span class="variable">$(comma)</span> , <span class="variable">$(foo)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all: </span></span><br><span class="line">    <span class="comment"># Output is &quot;, a , b , c&quot;. Notice the spaces introduced</span></span><br><span class="line">    @echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-2-字符串替换"><a href="#8-2-字符串替换" class="headerlink" title="8.2 字符串替换"></a>8.2 字符串替换</h3><p>$(patsubst pattern,replacement,text) 执行以下操作：</p>
<p>“Finds whitespace-separated words in text that match pattern and replaces them with replacement. Here pattern may contain a ‘%’ which acts as a wildcard, matching any number of any characters within a word. If replacement also contains a ‘%’, the ‘%’ is replaced by the text that matched the ‘%’ in pattern. Only the first ‘%’ in the pattern and replacement is treated this way; any subsequent ‘%’ is unchanged.” (<a target="_blank" rel="noopener" href="https://www.gnu.org/software/make/manual/html_node/Text-Functions.html#Text-Functions">GNU docs</a>)</p>
<p>替换引用 $(text:pattern&#x3D;replacement) 就是这种情况的简写。</p>
<p>还有一种只替换后缀的速记方法：$(text:sufficiency&#x3D;replacement)。这里不使用 % 通配符。</p>
<p>注意：不要为这种速记法添加额外的空格。它会被视为搜索或替换词。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o l.a c.o</span><br><span class="line">one := <span class="variable">$(<span class="built_in">patsubst</span> %.o,%.c,<span class="variable">$(foo)</span>)</span></span><br><span class="line"><span class="comment"># This is a shorthand for the above</span></span><br><span class="line">two := $(foo:%.o=%.c)</span><br><span class="line"><span class="comment"># This is the suffix-only shorthand, and is also equivalent to the above.</span></span><br><span class="line">three := $(foo:.o=.c)</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    echo <span class="variable">$(one)</span></span><br><span class="line">    echo <span class="variable">$(two)</span></span><br><span class="line">    echo <span class="variable">$(three)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-循环函数"><a href="#8-3-循环函数" class="headerlink" title="8.3 循环函数"></a>8.3 循环函数</h3><p>foreach 函数看起来像这样：$(foreach var,list,text).它将一个单词列表（用空格分隔）转换为另一个单词列表。var 设置为列表中的每个单词，text 则为每个单词扩展。</p>
<p>这会在每个单词后添加一个感叹号：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo := who are you</span><br><span class="line"><span class="comment"># For each &quot;word&quot; in foo, output that same word with an exclamation after</span></span><br><span class="line">bar := <span class="variable">$(<span class="built_in">foreach</span> wrd,<span class="variable">$(foo)</span>,<span class="variable">$(wrd)</span>!)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="comment"># Output is &quot;who! are! you!&quot;</span></span><br><span class="line">    @echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-if函数"><a href="#8-4-if函数" class="headerlink" title="8.4 if函数"></a>8.4 if函数</h3><p>if 检查第一个参数是否为非空。如果是，则运行第二个参数，否则运行第三个参数。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">foo := <span class="variable">$(<span class="built_in">if</span> this-is-not-empty,then!,else!)</span></span><br><span class="line">empty :=</span><br><span class="line">bar := <span class="variable">$(<span class="built_in">if</span> <span class="variable">$(empty)</span>,then!,else!)</span></span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    @echo <span class="variable">$(foo)</span></span><br><span class="line">    @echo <span class="variable">$(bar)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-call函数"><a href="#8-5-call函数" class="headerlink" title="8.5 call函数"></a>8.5 call函数</h3><p>Make 支持创建基本函数。您只需通过创建一个变量来 “define” 函数，但要使用 $(0)、$(1) 等参数。然后使用特殊的调用内置函数调用该函数。语法是 $(调用变量,参数,param)。$(0)是变量，$(1)、$(2)等是参数。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sweet_new_fn = Variable Name: $(0) First: $(1) Second: $(2) Empty Variable: $(3)</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">    <span class="comment"># Outputs &quot;Variable Name: sweet_new_fn First: go Second: tigers Empty Variable:&quot;</span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">call</span> sweet_new_fn, go, tigers)</span></span><br></pre></td></tr></table></figure>

<h3 id="8-6-shell函数"><a href="#8-6-shell函数" class="headerlink" title="8.6 shell函数"></a>8.6 shell函数</h3><p>shell - 调用 shell，但会用空格替换换行符！</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: </span></span><br><span class="line">    @echo <span class="variable">$(<span class="built_in">shell</span> ls -la)</span> <span class="comment"># Very ugly because the newlines are gone!</span></span><br></pre></td></tr></table></figure>

<h2 id="九-其他特性"><a href="#九-其他特性" class="headerlink" title="九. 其他特性"></a>九. 其他特性</h2><h3 id="9-1-包含-Makefile"><a href="#9-1-包含-Makefile" class="headerlink" title="9.1 包含 Makefile"></a>9.1 包含 Makefile</h3><p>include 指令告诉 make 读取一个或多个其他 makefile。这是 makefile 中的一行，看起来像这样：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> filenames...</span><br></pre></td></tr></table></figure>

<p>这在使用 -M 等编译器标志时特别有用，这些标志会根据源代码创建 Makefile。例如，如果某些 c 文件包含一个头文件，那么该头文件就会被添加到由 gcc 编写的 Makefile 中。我将在 Makefile Cookbook 中详细介绍这一点</p>
<h2 id="十-Makefile-Cookbook"><a href="#十-Makefile-Cookbook" class="headerlink" title="十. Makefile Cookbook"></a>十. Makefile Cookbook</h2><p>让我们来看看一个非常实用的 Make 示例，它非常适合中等规模的项目。</p>
<p>这个 makefile 最棒的地方在于它会自动为你确定依赖关系。你只需将 C&#x2F;C++ 文件放入 src&#x2F; 文件夹即可。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Thanks to Job Vranish (https://spin.atomicobject.com/2016/08/26/makefile-c-projects/)</span></span><br><span class="line">TARGET_EXEC := final_program</span><br><span class="line"></span><br><span class="line">BUILD_DIR := ./build</span><br><span class="line">SRC_DIRS := ./src</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find all the C and C++ files we want to compile</span></span><br><span class="line"><span class="comment"># Note the single quotes around the * expressions. The shell will incorrectly expand these otherwise, but we want to send the * directly to the find command.</span></span><br><span class="line">SRCS := <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIRS)</span> -name &#x27;*.cpp&#x27; -<span class="built_in">or</span> -name &#x27;*.c&#x27; -<span class="built_in">or</span> -name &#x27;*.s&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Prepends BUILD_DIR and appends .o to every src file</span></span><br><span class="line"><span class="comment"># As an example, ./your_dir/hello.cpp turns into ./build/./your_dir/hello.cpp.o</span></span><br><span class="line">OBJS := $(SRCS:%=<span class="variable">$(BUILD_DIR)</span>/%.o)</span><br><span class="line"></span><br><span class="line"><span class="comment"># String substitution (suffix version without %).</span></span><br><span class="line"><span class="comment"># As an example, ./build/hello.cpp.o turns into ./build/hello.cpp.d</span></span><br><span class="line">DEPS := $(OBJS:.o=.d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Every folder in ./src will need to be passed to GCC so that it can find header files</span></span><br><span class="line">INC_DIRS := <span class="variable">$(<span class="built_in">shell</span> find <span class="variable">$(SRC_DIRS)</span> -type d)</span></span><br><span class="line"><span class="comment"># Add a prefix to INC_DIRS. So moduleA would become -ImoduleA. GCC understands this -I flag</span></span><br><span class="line">INC_FLAGS := <span class="variable">$(<span class="built_in">addprefix</span> -I,<span class="variable">$(INC_DIRS)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The -MMD and -MP flags together generate Makefiles for us!</span></span><br><span class="line"><span class="comment"># These files will have .d instead of .o as the output.</span></span><br><span class="line">CPPFLAGS := <span class="variable">$(INC_FLAGS)</span> -MMD -MP</span><br><span class="line"></span><br><span class="line"><span class="comment"># The final build step.</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/<span class="variable">$(TARGET_EXEC)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(OBJS)</span> -o <span class="variable">$@</span> <span class="variable">$(LDFLAGS)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build step for C source</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.c.o: %.c</span><br><span class="line">    mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Build step for C++ source</span></span><br><span class="line"><span class="variable">$(BUILD_DIR)</span>/%.cpp.o: %.cpp</span><br><span class="line">    mkdir -p <span class="variable">$(<span class="built_in">dir</span> <span class="variable">$@</span>)</span></span><br><span class="line">    <span class="variable">$(CXX)</span> <span class="variable">$(CPPFLAGS)</span> <span class="variable">$(CXXFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -r <span class="variable">$(BUILD_DIR)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Include the .d makefiles. The - at the front suppresses the errors of missing</span></span><br><span class="line"><span class="comment"># Makefiles. Initially, all the .d files will be missing, and we don&#x27;t want those</span></span><br><span class="line"><span class="comment"># errors to show up.</span></span><br><span class="line"><span class="keyword">-include</span> <span class="variable">$(DEPS)</span></span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zzzzrf.github.io">zrf</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zzzzrf.github.io/2024/06/08/MakefileTutorial/">https://zzzzrf.github.io/2024/06/08/MakefileTutorial/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zzzzrf.github.io" target="_blank">zrf's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Makefile/">Makefile</a></div><div class="post-share"><div class="social-share" data-image="/blog_image/Makefile/1.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>感谢支持</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat_pay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat_pay.jpg"/></a><div class="post-qr-code-desc"></div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/05/26/trace_esp/" title="Trace ESP Packet"><img class="cover" src="/blog_image/XFRM-state/ipsec.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Trace ESP Packet</div></div><div class="info-2"><div class="info-item-1">分析一个ESP Packet在协议栈的input方向和output方向是如何处理的,仅仅涉及重要的函数名,用以显示调用关系与注册时机,不会陷入到具体的实现细节之中。</div></div></div></a><a class="pagination-related" href="/2024/06/16/vxlan_rfc7348/" title="VXLAN RFC7348"><img class="cover" src="/blog_image/rfc7348/00.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">VXLAN RFC7348</div></div><div class="info-2"><div class="info-item-1">详细介绍了VXLAN的需求和帧格式，简单提及了一些部署场景</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">zrf</div><div class="author-info-description">求知若渴，虚心若愚</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">35</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/zzzzrf"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/zzzzrf" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:853241825@qq.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">蹒跚学步,感谢支持!</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-Getting-Started"><span class="toc-number">2.</span> <span class="toc-text">一. Getting Started</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81Makefile"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 为什么需要Makefile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E9%99%A4%E4%BA%86Makefile%E8%BF%98%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B6%E4%BB%96%E9%80%89%E6%8B%A9"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 除了Makefile还有什么其他选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%90%E8%A1%8C%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.</span> <span class="toc-text">1.3 运行示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-Makefile%E8%AF%AD%E6%B3%95"><span class="toc-number">2.4.</span> <span class="toc-text">1.4 Makefile语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-Make%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.5.</span> <span class="toc-text">1.5 Make的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E6%9B%B4%E5%A4%9A%E5%BF%AB%E9%80%9F%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.</span> <span class="toc-text">1.6 更多快速示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Make-clean"><span class="toc-number">2.7.</span> <span class="toc-text">1.7 Make clean</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-8-%E5%8F%98%E9%87%8F"><span class="toc-number">2.8.</span> <span class="toc-text">1.8 变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-Target"><span class="toc-number">3.</span> <span class="toc-text">二. Target</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-all-target"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 all target</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%9A%E7%9B%AE%E6%A0%87"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 多目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">4.</span> <span class="toc-text">三. 自动变量和通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-wildcard"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 * wildcard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-Wildcard"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 % Wildcard</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 自动变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E8%A7%84%E5%88%99"><span class="toc-number">5.</span> <span class="toc-text">四. 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9A%90%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 隐式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 静态模式规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F%E8%A7%84%E5%88%99%E5%92%8C%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">4.3 静态模式规则和过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-Pattern-Rules"><span class="toc-number">5.4.</span> <span class="toc-text">4.4 Pattern Rules</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E5%8F%8C%E5%86%92%E5%8F%B7%E8%A7%84%E5%88%99"><span class="toc-number">5.5.</span> <span class="toc-text">4.5 双冒号规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-Commands-and-execution"><span class="toc-number">6.</span> <span class="toc-text">五. Commands and execution</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E8%BE%93%E5%87%BA-%E9%9D%99%E9%BB%98"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 命令行的输出&#x2F;静默</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 命令行的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%BB%98%E8%AE%A4shell"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 默认shell</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8F%8C%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 双美元符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E4%BD%BF%E7%94%A8-k%E3%80%81-i-%E5%92%8C-%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">6.5.</span> <span class="toc-text">5.5 使用 -k、-i 和 - 处理错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E4%B8%AD%E6%96%AD%E6%88%96%E6%9D%80%E6%AD%BB"><span class="toc-number">6.6.</span> <span class="toc-text">5.6 中断或杀死</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-make-%E7%9A%84%E9%80%92%E5%BD%92%E4%BD%BF%E7%94%A8"><span class="toc-number">6.7.</span> <span class="toc-text">5.7 make 的递归使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-%E5%AF%BC%E5%87%BA%E3%80%81%E7%8E%AF%E5%A2%83%E5%92%8C%E9%80%92%E5%BD%92-make"><span class="toc-number">6.8.</span> <span class="toc-text">5.8 导出、环境和递归 make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-make%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">6.9.</span> <span class="toc-text">5.9 make的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E5%8F%98%E9%87%8F-2"><span class="toc-number">7.</span> <span class="toc-text">六. 变量 2</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-Flavors-and-modification"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 Flavors and modification</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E5%92%8C%E8%A6%86%E7%9B%96"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 命令行参数和覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-List-of-commands-and-define"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 List of commands and define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-Target-specific-variables"><span class="toc-number">7.4.</span> <span class="toc-text">6.4 Target-specific variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-Pattern-specific-variables"><span class="toc-number">7.5.</span> <span class="toc-text">6.5 Pattern-specific variables</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD"><span class="toc-number">8.</span> <span class="toc-text">七. 条件判断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-if-else"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 if&#x2F;else</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%A3%80%E6%9F%A5%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 检查变量是否为空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E6%A3%80%E6%9F%A5%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%B7%B2%E5%AE%9A%E4%B9%89"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 检查变量是否已定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-MAKEFLAGS"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 $(MAKEFLAGS)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-%E5%87%BD%E6%95%B0"><span class="toc-number">9.</span> <span class="toc-text">八. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-First-function"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 First function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 字符串替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E5%BE%AA%E7%8E%AF%E5%87%BD%E6%95%B0"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 循环函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-if%E5%87%BD%E6%95%B0"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 if函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-call%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">8.5 call函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-shell%E5%87%BD%E6%95%B0"><span class="toc-number">9.6.</span> <span class="toc-text">8.6 shell函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="toc-number">10.</span> <span class="toc-text">九. 其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E5%8C%85%E5%90%AB-Makefile"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 包含 Makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-Makefile-Cookbook"><span class="toc-number">11.</span> <span class="toc-text">十. Makefile Cookbook</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/mac_learning/" title="mac地址学习"><img src="/blog_image/bridge_env/bridge_env_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mac地址学习"/></a><div class="content"><a class="title" href="/2025/04/03/mac_learning/" title="mac地址学习">mac地址学习</a><time datetime="2025-04-03T15:16:28.000Z" title="发表于 2025-04-03 23:16:28">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/03/bridge_env/" title="bridge"><img src="/blog_image/bridge_env/bridge_env_bg.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="bridge"/></a><div class="content"><a class="title" href="/2025/04/03/bridge_env/" title="bridge">bridge</a><time datetime="2025-04-03T13:21:34.000Z" title="发表于 2025-04-03 21:21:34">2025-04-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/09/20250222/" title="务虚笔记"><img src="/blog_image/20250222/7b4a8bee660a1d4165f0206cb8990c3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="务虚笔记"/></a><div class="content"><a class="title" href="/2025/03/09/20250222/" title="务虚笔记">务虚笔记</a><time datetime="2025-03-09T02:15:21.000Z" title="发表于 2025-03-09 10:15:21">2025-03-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/02/20250322/" title="我的丁一之旅"><img src="/blog_image/20250322/wuxubiji.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="我的丁一之旅"/></a><div class="content"><a class="title" href="/2025/03/02/20250322/" title="我的丁一之旅">我的丁一之旅</a><time datetime="2025-03-02T03:25:42.000Z" title="发表于 2025-03-02 11:25:42">2025-03-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/02/15/20250215/" title="悉达多"><img src="/blog_image/20250215/CMCoOScDbDY0AAV3-wBgpff5.jpeg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="悉达多"/></a><div class="content"><a class="title" href="/2025/02/15/20250215/" title="悉达多">悉达多</a><time datetime="2025-02-15T11:17:26.000Z" title="发表于 2025-02-15 19:17:26">2025-02-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/06/rpi_HelloWorld/" title="裸机程序hello world"><img src="/blog_image/rpi_HelloWorld/hello_world.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="裸机程序hello world"/></a><div class="content"><a class="title" href="/2024/07/06/rpi_HelloWorld/" title="裸机程序hello world">裸机程序hello world</a><time datetime="2024-07-06T15:42:18.000Z" title="发表于 2024-07-06 23:42:18">2024-07-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/back.jpeg);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By zrf</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to zrf's <a href="https://zzzzrf.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = "留下你的足迹o(*￣▽￣*)ブ"

  const initValine = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyValine = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const valineConfig = {
      el: '#vcomment',
      appId: 'mHV5QZzhNBabMj6y5kw2SYqq-gzGzoHsz',
      appKey: '2fvaL99PG3kQNK15rc70qhMV',
      avatar: 'monsterid',
      serverURLs: 'https://mhv5qzzh.lc-cn-n1-shared.com',
      emojiMaps: "",
      visitor: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || window.location.pathname
    }

    new Valine(valineConfig)
  }

  const loadValine = async (el, path) => {
    if (typeof Valine === 'function') {
      initValine(el, path)
    } else {
      await btf.getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js')
      initValine(el, path)
    }
  }

  if (isShuoshuo) {
    'Valine' === 'Valine'
      ? window.shuoshuoComment = { loadComment: loadValine }
      : window.loadOtherComment = loadValine
    return
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>